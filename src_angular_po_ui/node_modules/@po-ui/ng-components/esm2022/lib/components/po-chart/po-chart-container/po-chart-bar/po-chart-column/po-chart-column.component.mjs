import { Component } from '@angular/core';
import { PoChartPlotAreaPaddingTop } from '../../../helpers/po-chart-default-values.constant';
import { PoChartBarBaseComponent } from '../po-chart-bar-base.component';
import * as i0 from "@angular/core";
import * as i1 from "../../../services/po-chart-maths.service";
import * as i2 from "@angular/common";
import * as i3 from "../po-chart-bar-path/po-chart-bar-path.component";
const _c0 = ["po-chart-column", ""];
function PoChartColumnComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    const _r4 = i0.ɵɵgetCurrentView();
    i0.ɵɵnamespaceSVG();
    i0.ɵɵelementStart(0, "g")(1, "g", 1);
    i0.ɵɵlistener("p-bar-click", function PoChartColumnComponent__svg_g_1_Template__svg_g_p_bar_click_1_listener($event) { i0.ɵɵrestoreView(_r4); const ctx_r3 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r3.onSerieBarClick($event)); })("p-bar-hover", function PoChartColumnComponent__svg_g_1_Template__svg_g_p_bar_hover_1_listener($event) { i0.ɵɵrestoreView(_r4); const ctx_r5 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r5.onSerieBarHover($event)); });
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵclassMap("po-chart-bar-group-" + i_r2);
    i0.ɵɵadvance();
    i0.ɵɵproperty("p-color", item_r1[0] == null ? null : item_r1[0].color)("p-coordinates", item_r1)("p-tooltip-position", ctx_r0.tooltipPosition);
    i0.ɵɵattribute("key", "po-chart-bar-path-" + i_r2);
} }
export class PoChartColumnComponent extends PoChartBarBaseComponent {
    mathsService;
    tooltipPosition = 'top';
    constructor(mathsService) {
        super(mathsService);
        this.mathsService = mathsService;
    }
    barCoordinates(seriesIndex, serieItemDataIndex, containerSize, minMaxSeriesValues, serieValue) {
        const { svgWidth, axisXLabelWidth, svgPlottingAreaHeight } = containerSize;
        const { chartBarPlotArea, barWidth, spaceBetweenBars } = this.calculateElementsMeasurements(svgWidth, axisXLabelWidth);
        const { x1, x2 } = this.xCoordinates(seriesIndex, serieItemDataIndex, chartBarPlotArea, barWidth, spaceBetweenBars, axisXLabelWidth);
        const { y1, y2 } = this.yCoordinates(minMaxSeriesValues, svgPlottingAreaHeight, serieValue);
        return ['M', x1, y2, 'L', x2, y2, 'L', x2, y1, 'L', x1, y1, 'z'].join(' ');
    }
    calculateElementsMeasurements(svgWidth, axisXLabelWidth) {
        // Fração das séries em relação à largura da categoria. Incrementa + 2 na extensão das séries pois se trata da área de margem entre as categorias.
        const chartBarPlotArea = svgWidth - axisXLabelWidth;
        const categoryWidth = chartBarPlotArea / this.seriesGreaterLength;
        const columnFraction = categoryWidth / (this.series.length + 2);
        // Área entre as colunas: retorna zero se houver apenas uma série.
        const spaceBetweenBars = this.series.length > 1 ? columnFraction / (this.series.length + 2) : 0;
        // Subtrai a fração das séries pelo espaço entre as colunas.
        const barWidth = columnFraction - (spaceBetweenBars * (this.series.length - 1)) / (this.series.length + 2);
        return { chartBarPlotArea, barWidth, spaceBetweenBars };
    }
    xCoordinates(seriesIndex, serieItemDataIndex, chartBarPlotArea, barWidth, spaceBetweenBars, axisXLabelWidth) {
        // A área lateral entre a coluna e a linha do eixo Y do grid será sempre equivalente à largura da coluna.
        const spaceBetweenAxisAndBars = barWidth;
        const xRatio = serieItemDataIndex / this.seriesGreaterLength;
        const x1 = Math.round(axisXLabelWidth +
            chartBarPlotArea * xRatio +
            spaceBetweenAxisAndBars +
            barWidth * seriesIndex +
            spaceBetweenBars * seriesIndex);
        const x2 = Math.round(x1 + barWidth);
        return { x1, x2 };
    }
    yCoordinates(minMaxSeriesValues, svgPlottingAreaHeight, serieValue) {
        const { minValue } = minMaxSeriesValues;
        const minValuePercentage = this.mathsService.getSeriePercentage(minMaxSeriesValues, minValue < 0 ? 0 : minValue);
        const y1 = Math.round(svgPlottingAreaHeight - svgPlottingAreaHeight * minValuePercentage + PoChartPlotAreaPaddingTop);
        const yRatio = this.mathsService.getSeriePercentage(minMaxSeriesValues, serieValue);
        const y2 = Math.round(svgPlottingAreaHeight - svgPlottingAreaHeight * yRatio + PoChartPlotAreaPaddingTop);
        return { y1, y2 };
    }
    static ɵfac = function PoChartColumnComponent_Factory(t) { return new (t || PoChartColumnComponent)(i0.ɵɵdirectiveInject(i1.PoChartMathsService)); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: PoChartColumnComponent, selectors: [["", "po-chart-column", ""]], features: [i0.ɵɵInheritDefinitionFeature], attrs: _c0, decls: 2, vars: 2, consts: [[3, "class", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["po-chart-bar-path", "", 3, "p-color", "p-coordinates", "p-tooltip-position", "p-bar-click", "p-bar-hover"]], template: function PoChartColumnComponent_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵnamespaceSVG();
            i0.ɵɵelementStart(0, "g");
            i0.ɵɵtemplate(1, PoChartColumnComponent__svg_g_1_Template, 2, 6, "g", 0);
            i0.ɵɵelementEnd();
        } if (rf & 2) {
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngForOf", ctx.seriesPathsCoordinates)("ngForTrackBy", ctx.trackBy);
        } }, dependencies: [i2.NgForOf, i3.PoChartBarPathComponent], encapsulation: 2 });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PoChartColumnComponent, [{
        type: Component,
        args: [{ selector: '[po-chart-column]', template: "<svg:g>\n  <svg:g *ngFor=\"let item of seriesPathsCoordinates; let i = index; trackBy: trackBy\"\n    [class]=\"'po-chart-bar-group-' + i\"\n  >\n    <!-- SERIES PATHS -->\n    <svg:g po-chart-bar-path\n      [attr.key]=\"'po-chart-bar-path-' + i\"\n      [p-color]=\"item[0]?.color\" \n      [p-coordinates]=\"item\"\n      [p-tooltip-position]=\"tooltipPosition\"\n      (p-bar-click)=\"onSerieBarClick($event)\"\n      (p-bar-hover)=\"onSerieBarHover($event)\"\n      >\n      </svg:g>\n  </svg:g>\n</svg:g>" }]
    }], () => [{ type: i1.PoChartMathsService }], null); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(PoChartColumnComponent, { className: "PoChartColumnComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-bar/po-chart-column/po-chart-column.component.ts", lineNumber: 15 }); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tY2hhcnQtY29sdW1uLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3VpL3NyYy9saWIvY29tcG9uZW50cy9wby1jaGFydC9wby1jaGFydC1jb250YWluZXIvcG8tY2hhcnQtYmFyL3BvLWNoYXJ0LWNvbHVtbi9wby1jaGFydC1jb2x1bW4uY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvdWkvc3JjL2xpYi9jb21wb25lbnRzL3BvLWNoYXJ0L3BvLWNoYXJ0LWNvbnRhaW5lci9wby1jaGFydC1iYXIvcG8tY2hhcnQtYmFyLmNvbXBvbmVudC5zdmciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUxQyxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxtREFBbUQsQ0FBQztBQUU5RixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQzs7Ozs7Ozs7O0lDSHZFLHlCQUVDLFdBQUE7SUFPRyx3TEFBZSxlQUFBLDhCQUF1QixDQUFBLElBQUMsMktBQ3hCLGVBQUEsOEJBQXVCLENBQUEsSUFEQztJQUd2QyxpQkFBUSxFQUFBOzs7OztJQVhWLDJDQUFtQztJQUtqQyxjQUEwQjtJQUExQixzRUFBMEIsMEJBQUEsOENBQUE7SUFEMUIsa0RBQXFDOztBRFEzQyxNQUFNLE9BQU8sc0JBQXVCLFNBQVEsdUJBQXVCO0lBRzNDO0lBRmIsZUFBZSxHQUFHLEtBQUssQ0FBQztJQUVqQyxZQUFzQixZQUFpQztRQUNyRCxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7UUFEQSxpQkFBWSxHQUFaLFlBQVksQ0FBcUI7SUFFdkQsQ0FBQztJQUVTLGNBQWMsQ0FDdEIsV0FBbUIsRUFDbkIsa0JBQTBCLEVBQzFCLGFBQW1DLEVBQ25DLGtCQUF1QyxFQUN2QyxVQUFr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a0JBQWtCLEVBQUUsUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNqSCxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUNuQixxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyx5QkFBeUIsQ0FDL0YsQ0FBQztRQUVGLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsa0JBQWtCLENBQUMsa0JBQWtCLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDcEYsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxNQUFNLEdBQUcseUJBQXlCLENBQUMsQ0FBQztRQUUxRyxPQUFPLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO0lBQ3BCLENBQUM7Z0ZBdkZVLHNCQUFzQjs2REFBdEIsc0JBQXNCO1lDZG5DLG1CQUFPO1lBQVAseUJBQU87WUFDTCx3RUFhUTtZQUNWLGlCQUFROztZQWRrQixjQUEyQjtZQUEzQixvREFBMkIsNkJBQUE7OztpRkRheEMsc0JBQXNCO2NBSmxDLFNBQVM7MkJBQ0UsbUJBQW1COztrRkFHbEIsc0JBQXNCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFBvQ2hhcnRQbG90QXJlYVBhZGRpbmdUb3AgfSBmcm9tICcuLi8uLi8uLi9oZWxwZXJzL3BvLWNoYXJ0LWRlZmF1bHQtdmFsdWVzLmNvbnN0YW50JztcblxuaW1wb3J0IHsgUG9DaGFydEJhckJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9wby1jaGFydC1iYXItYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUG9DaGFydE1hdGhzU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZpY2VzL3BvLWNoYXJ0LW1hdGhzLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBQb0NoYXJ0Q29udGFpbmVyU2l6ZSB9IGZyb20gJy4uLy4uLy4uL2ludGVyZmFjZXMvcG8tY2hhcnQtY29udGFpbmVyLXNpemUuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBvQ2hhcnRNaW5NYXhWYWx1ZXMgfSBmcm9tICcuLi8uLi8uLi9pbnRlcmZhY2VzL3BvLWNoYXJ0LW1pbi1tYXgtdmFsdWVzLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ1twby1jaGFydC1jb2x1bW5dJyxcbiAgdGVtcGxhdGVVcmw6ICcuLi9wby1jaGFydC1iYXIuY29tcG9uZW50LnN2Zydcbn0pXG5leHBvcnQgY2xhc3MgUG9DaGFydENvbHVtbkNvbXBvbmVudCBleHRlbmRzIFBvQ2hhcnRCYXJCYXNlQ29tcG9uZW50IHtcbiAgcmVhZG9ubHkgdG9vbHRpcFBvc2l0aW9uID0gJ3RvcCc7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIG1hdGhzU2VydmljZTogUG9DaGFydE1hdGhzU2VydmljZSkge1xuICAgIHN1cGVyKG1hdGhzU2VydmljZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYmFyQ29vcmRpbmF0ZXMoXG4gICAgc2VyaWVzSW5kZXg6IG51bWJlcixcbiAgICBzZXJpZUl0ZW1EYXRhSW5kZXg6IG51bWJlcixcbiAgICBjb250YWluZXJTaXplOiBQb0NoYXJ0Q29udGFpbmVyU2l6ZSxcbiAgICBtaW5NYXhTZXJpZXNWYWx1ZXM6IFBvQ2hhcnRNaW5NYXhWYWx1ZXMsXG4gICAgc2VyaWVWYWx1ZTogbnVtYmVyXG4gICkge1xuICAgIGNvbnN0IHsgc3ZnV2lkdGgsIGF4aXNYTGFiZWxXaWR0aCwgc3ZnUGxvdHRpbmdBcmVhSGVpZ2h0IH0gPSBjb250YWluZXJTaXplO1xuICAgIGNvbnN0IHsgY2hhcnRCYXJQbG90QXJlYSwgYmFyV2lkdGgsIHNwYWNlQmV0d2VlbkJhcnMgfSA9IHRoaXMuY2FsY3VsYXRlRWxlbWVudHNNZWFzdXJlbWVudHMoXG4gICAgICBzdmdXaWR0aCxcbiAgICAgIGF4aXNYTGFiZWxXaWR0aFxuICAgICk7XG5cbiAgICBjb25zdCB7IHgxLCB4MiB9ID0gdGhpcy54Q29vcmRpbmF0ZXMoXG4gICAgICBzZXJpZXNJbmRleCxcbiAgICAgIHNlcmllSXRlbURhdGFJbmRleCxcbiAgICAgIGNoYXJ0QmFyUGxvdEFyZWEsXG4gICAgICBiYXJXaWR0aCxcbiAgICAgIHNwYWNlQmV0d2VlbkJhcnMsXG4gICAgICBheGlzWExhYmVsV2lkdGhcbiAgICApO1xuICAgIGNvbnN0IHsgeTEsIHkyIH0gPSB0aGlzLnlDb29yZGluYXRlcyhtaW5NYXhTZXJpZXNWYWx1ZXMsIHN2Z1Bsb3R0aW5nQXJlYUhlaWdodCwgc2VyaWVWYWx1ZSk7XG5cbiAgICByZXR1cm4gWydNJywgeDEsIHkyLCAnTCcsIHgyLCB5MiwgJ0wnLCB4MiwgeTEsICdMJywgeDEsIHkxLCAneiddLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlRWxlbWVudHNNZWFzdXJlbWVudHMoXG4gICAgc3ZnV2lkdGg6IFBvQ2hhcnRDb250YWluZXJTaXplWydzdmdXaWR0aCddLFxuICAgIGF4aXNYTGFiZWxXaWR0aDogUG9DaGFydENvbnRhaW5lclNpemVbJ2F4aXNYTGFiZWxXaWR0aCddXG4gICkge1xuICAgIC8vIEZyYcOnw6NvIGRhcyBzw6lyaWVzIGVtIHJlbGHDp8OjbyDDoCBsYXJndXJhIGRhIGNhdGVnb3JpYS4gSW5jcmVtZW50YSArIDIgbmEgZXh0ZW5zw6NvIGRhcyBzw6lyaWVzIHBvaXMgc2UgdHJhdGEgZGEgw6FyZWEgZGUgbWFyZ2VtIGVudHJlIGFzIGNhdGVnb3JpYXMuXG4gICAgY29uc3QgY2hhcnRCYXJQbG90QXJlYSA9IHN2Z1dpZHRoIC0gYXhpc1hMYWJlbFdpZHRoO1xuICAgIGNvbnN0IGNhdGVnb3J5V2lkdGggPSBjaGFydEJhclBsb3RBcmVhIC8gdGhpcy5zZXJpZXNHcmVhdGVyTGVuZ3RoO1xuICAgIGNvbnN0IGNvbHVtbkZyYWN0aW9uID0gY2F0ZWdvcnlXaWR0aCAvICh0aGlzLnNlcmllcy5sZW5ndGggKyAyKTtcblxuICAgIC8vIMOBcmVhIGVudHJlIGFzIGNvbHVuYXM6IHJldG9ybmEgemVybyBzZSBob3V2ZXIgYXBlbmFzIHVtYSBzw6lyaWUuXG4gICAgY29uc3Qgc3BhY2VCZXR3ZWVuQmFycyA9IHRoaXMuc2VyaWVzLmxlbmd0aCA+IDEgPyBjb2x1bW5GcmFjdGlvbiAvICh0aGlzLnNlcmllcy5sZW5ndGggKyAyKSA6IDA7XG5cbiAgICAvLyBTdWJ0cmFpIGEgZnJhw6fDo28gZGFzIHPDqXJpZXMgcGVsbyBlc3Bhw6dvIGVudHJlIGFzIGNvbHVuYXMuXG4gICAgY29uc3QgYmFyV2lkdGggPSBjb2x1bW5GcmFjdGlvbiAtIChzcGFjZUJldHdlZW5CYXJzICogKHRoaXMuc2VyaWVzLmxlbmd0aCAtIDEpKSAvICh0aGlzLnNlcmllcy5sZW5ndGggKyAyKTtcblxuICAgIHJldHVybiB7IGNoYXJ0QmFyUGxvdEFyZWEsIGJhcldpZHRoLCBzcGFjZUJldHdlZW5CYXJzIH07XG4gIH1cblxuICBwcml2YXRlIHhDb29yZGluYXRlcyhcbiAgICBzZXJpZXNJbmRleDogbnVtYmVyLFxuICAgIHNlcmllSXRlbURhdGFJbmRleDogbnVtYmVyLFxuICAgIGNoYXJ0QmFyUGxvdEFyZWE6IG51bWJlcixcbiAgICBiYXJXaWR0aDogbnVtYmVyLFxuICAgIHNwYWNlQmV0d2VlbkJhcnM6IG51bWJlcixcbiAgICBheGlzWExhYmVsV2lkdGg6IFBvQ2hhcnRDb250YWluZXJTaXplWydheGlzWExhYmVsV2lkdGgnXVxuICApIHtcbiAgICAvLyBBIMOhcmVhIGxhdGVyYWwgZW50cmUgYSBjb2x1bmEgZSBhIGxpbmhhIGRvIGVpeG8gWSBkbyBncmlkIHNlcsOhIHNlbXByZSBlcXVpdmFsZW50ZSDDoCBsYXJndXJhIGRhIGNvbHVuYS5cbiAgICBjb25zdCBzcGFjZUJldHdlZW5BeGlzQW5kQmFycyA9IGJhcldpZHRoO1xuICAgIGNvbnN0IHhSYXRpbyA9IHNlcmllSXRlbURhdGFJbmRleCAvIHRoaXMuc2VyaWVzR3JlYXRlckxlbmd0aDtcblxuICAgIGNvbnN0IHgxID0gTWF0aC5yb3VuZChcbiAgICAgIGF4aXNYTGFiZWxXaWR0aCArXG4gICAgICAgIGNoYXJ0QmFyUGxvdEFyZWEgKiB4UmF0aW8gK1xuICAgICAgICBzcGFjZUJldHdlZW5BeGlzQW5kQmFycyArXG4gICAgICAgIGJhcldpZHRoICogc2VyaWVzSW5kZXggK1xuICAgICAgICBzcGFjZUJldHdlZW5CYXJzICogc2VyaWVzSW5kZXhcbiAgICApO1xuXG4gICAgY29uc3QgeDIgPSBNYXRoLnJvdW5kKHgxICsgYmFyV2lkdGgpO1xuXG4gICAgcmV0dXJuIHsgeDEsIHgyIH07XG4gIH1cblxuICBwcml2YXRlIHlDb29yZGluYXRlcyhtaW5NYXhTZXJpZXNWYWx1ZXM6IFBvQ2hhcnRNaW5NYXhWYWx1ZXMsIHN2Z1Bsb3R0aW5nQXJlYUhlaWdodDogbnVtYmVyLCBzZXJpZVZhbHVlOiBudW1iZXIpIHtcbiAgICBjb25zdCB7IG1pblZhbHVlIH0gPSBtaW5NYXhTZXJpZXNWYWx1ZXM7XG4gICAgY29uc3QgbWluVmFsdWVQZXJjZW50YWdlID0gdGhpcy5tYXRoc1NlcnZpY2UuZ2V0U2VyaWVQZXJjZW50YWdlKG1pbk1heFNlcmllc1ZhbHVlcywgbWluVmFsdWUgPCAwID8gMCA6IG1pblZhbHVlKTtcbiAgICBjb25zdCB5MSA9IE1hdGgucm91bmQoXG4gICAgICBzdmdQbG90dGluZ0FyZWFIZWlnaHQgLSBzdmdQbG90dGluZ0FyZWFIZWlnaHQgKiBtaW5WYWx1ZVBlcmNlbnRhZ2UgKyBQb0NoYXJ0UGxvdEFyZWFQYWRkaW5nVG9wXG4gICAgKTtcblxuICAgIGNvbnN0IHlSYXRpbyA9IHRoaXMubWF0aHNTZXJ2aWNlLmdldFNlcmllUGVyY2VudGFnZShtaW5NYXhTZXJpZXNWYWx1ZXMsIHNlcmllVmFsdWUpO1xuICAgIGNvbnN0IHkyID0gTWF0aC5yb3VuZChzdmdQbG90dGluZ0FyZWFIZWlnaHQgLSBzdmdQbG90dGluZ0FyZWFIZWlnaHQgKiB5UmF0aW8gKyBQb0NoYXJ0UGxvdEFyZWFQYWRkaW5nVG9wKTtcblxuICAgIHJldHVybiB7IHkxLCB5MiB9O1xuICB9XG59XG4iLCI8c3ZnOmc+XG4gIDxzdmc6ZyAqbmdGb3I9XCJsZXQgaXRlbSBvZiBzZXJpZXNQYXRoc0Nvb3JkaW5hdGVzOyBsZXQgaSA9IGluZGV4OyB0cmFja0J5OiB0cmFja0J5XCJcbiAgICBbY2xhc3NdPVwiJ3BvLWNoYXJ0LWJhci1ncm91cC0nICsgaVwiXG4gID5cbiAgICA8IS0tIFNFUklFUyBQQVRIUyAtLT5cbiAgICA8c3ZnOmcgcG8tY2hhcnQtYmFyLXBhdGhcbiAgICAgIFthdHRyLmtleV09XCIncG8tY2hhcnQtYmFyLXBhdGgtJyArIGlcIlxuICAgICAgW3AtY29sb3JdPVwiaXRlbVswXT8uY29sb3JcIiBcbiAgICAgIFtwLWNvb3JkaW5hdGVzXT1cIml0ZW1cIlxuICAgICAgW3AtdG9vbHRpcC1wb3NpdGlvbl09XCJ0b29sdGlwUG9zaXRpb25cIlxuICAgICAgKHAtYmFyLWNsaWNrKT1cIm9uU2VyaWVCYXJDbGljaygkZXZlbnQpXCJcbiAgICAgIChwLWJhci1ob3Zlcik9XCJvblNlcmllQmFySG92ZXIoJGV2ZW50KVwiXG4gICAgICA+XG4gICAgICA8L3N2ZzpnPlxuICA8L3N2ZzpnPlxuPC9zdmc6Zz4iXX0=