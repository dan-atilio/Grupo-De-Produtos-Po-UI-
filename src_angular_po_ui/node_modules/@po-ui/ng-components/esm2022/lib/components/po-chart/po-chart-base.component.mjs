import { EventEmitter, Input, Output, Directive } from '@angular/core';
import { convertToInt, isTypeof } from '../../utils/util';
import { PoChartType } from './enums/po-chart-type.enum';
import * as i0 from "@angular/core";
import * as i1 from "../../services/po-color/po-color.service";
const poChartDefaultHeight = 400;
const poChartMinHeight = 200;
/**
 * @description
 *
 * O `po-chart` é um componente para renderização de dados através de gráficos, com isso facilitando a compreensão e tornando a
 * visualização destes dados mais agradável.
 *
 * Através de suas principais propriedades é possível definir atributos, tais como tipo de gráfico, altura, título, cores customizadas, opções para os eixos, entre outros.
 *
 * O componente permite utilizar em conjunto séries do tipo linha e coluna.
 *
 * Além disso, também é possível definir uma ação que será executada ao clicar em determinado elemento do gráfico
 * e outra que será executada ao passar o *mouse* sobre o elemento.
 *
 * #### Guia de uso para Gráficos
 *
 * > Veja nosso [guia de uso para gráficos](/guides/guide-charts) para auxiliar na construção do seu gráfico,
 * informando em qual caso utilizar, o que devemos evitar e boas práticas relacionada a cores.
 */
export class PoChartBaseComponent {
    colorService;
    /** Define o título do gráfico. */
    title;
    /**
     * @optional
     *
     * @description
     *
     * Evento executado quando o usuário clicar sobre um elemento do gráfico.
     *
     * O evento emitirá o seguinte parâmetro:
     * - *donut* e *pie*: um objeto contendo a categoria e valor da série.
     * - *area*, *line*, *column* e *bar*: um objeto contendo o nome da série, valor e categoria do eixo do gráfico.
     */
    seriesClick = new EventEmitter();
    /**
     * @optional
     *
     * @description
     *
     * Evento executado quando o usuário passar o *mouse* sobre um elemento do gráfico.
     *
     * O evento emitirá o seguinte parâmetro de acordo com o tipo de gráfico:
     * - *donut* e *pie*: um objeto contendo a categoria e valor da série.
     * - *area*, *line*, *column* e *bar*: um objeto contendo a categoria, valor da série e categoria do eixo do gráfico.
     */
    seriesHover = new EventEmitter();
    // manipulação das séries tratadas internamente para preservar 'p-series';
    chartSeries = [];
    chartType;
    svgContainerSize;
    _options;
    _categories;
    _height;
    _series;
    _type;
    defaultType;
    /**
     * @optional
     *
     * @description
     *
     * Define a altura do gráfico.
     *
     * > O valor mínimo aceito nesta propriedade é 200.
     *
     * @default `400px`
     */
    set height(value) {
        const intValue = convertToInt(value);
        let height;
        if (isTypeof(value, 'number')) {
            height = intValue <= poChartMinHeight ? poChartMinHeight : intValue;
        }
        else {
            height = this.setDefaultHeight();
        }
        this._height = height;
        this.getSvgContainerSize();
        this.rebuildComponentRef();
    }
    get height() {
        return this._height || this.setDefaultHeight();
    }
    /**
     * @optional
     *
     * @description
     *
     * Define o tipo de gráfico.
     *
     * É possível também combinar gráficos dos tipos linha e coluna. Para isso, opte pela declaração de `type` conforme a interface `PoChartSerie`.
     *
     * > Note que, se houver declaração de tipo de gráfico tanto em `p-type` quanto em `PochartSerie.type`, o valor `{ type }` da primeira série anulará o valor definido em `p-type`.
     *
     * Se não passado valor, o padrão será relativo à primeira série passada em `p-series`:
     * - Se `p-series = [{ data: [1,2,3] }]`: será `PoChartType.Column`.
     * - Se `p-series = [{ data: 1 }]`: será `PoChartType.Pie`.
     *
     * > Veja os valores válidos no *enum* `PoChartType`.
     */
    set type(value) {
        // O Valor default definido em `p-series` de acordo com a primeira série passada.
        this._type = Object.values(PoChartType).includes(value) ? value : undefined;
        this.rebuildComponentRef();
    }
    get type() {
        return this._type;
    }
    /**
     * @description
     *
     * Define os elementos do gráfico que serão criados dinamicamente.
     */
    set series(value) {
        this._series = value || [];
        if (Array.isArray(this._series) && this._series.length) {
            this.setTypeDefault(this._series[0]);
        }
        else {
            this.transformObjectToArrayObject(this.series);
            this.rebuildComponentRef();
        }
    }
    get series() {
        return this._series;
    }
    /**
     * @optional
     *
     * @description
     *
     * Define os nomes das categorias que serão plotadas no eixo X do gráfico caso seja do tipo `bar`, ou então nos eixos Y do grid de gráficos dos tipos `area`, `columnn` e `line`.
     *
     * > Gráficos do tipo `bar` dimensionam a área do gráfico de acordo com a largura do maior texto de categorias. No entanto, é uma boa prática optar por palavras curtas para que a leitura do gráfico não seja prejudicada.
     *
     * > Caso não seja especificado um valor para a categoria, será plotado um hífen na categoria referente a cada série.
     */
    set categories(value) {
        if (Array.isArray(value)) {
            this._categories = value;
        }
    }
    get categories() {
        return this._categories;
    }
    /**
     * @optional
     *
     * @description
     *
     * Objeto com as configurações usadas no `po-chart`.
     *
     * É possível, por exemplo, definir as configurações de exibição das legendas,
     * configurar os eixos(*axis*) para os gráficos dos tipos `area`, `line`, `column` e `bar` da seguinte forma:
     *
     * ```
     *  chartOptions: PoChartOptions = {
     *    legend: true,
     *    axis: {
     *      minRange: 0,
     *      maxRange: 100,
     *      gridLines: 5,
     *    },
     *  };
     * ```
     */
    set options(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._options = value;
            if (this._options.hasOwnProperty('legend') && typeof this._options.legend === 'boolean') {
                this.getSvgContainerSize();
            }
        }
    }
    get options() {
        return this._options;
    }
    constructor(colorService) {
        this.colorService = colorService;
    }
    get isTypeCircular() {
        return this.defaultType === PoChartType.Pie || this.defaultType === PoChartType.Donut;
    }
    ngOnChanges(changes) {
        const isArrayOfseries = Array.isArray(this.series) && this.series.length > 0;
        if ((changes.series && isArrayOfseries) ||
            (changes.type && isArrayOfseries) ||
            (changes.categories && isArrayOfseries)) {
            this.validateSerieAndAddType(this.series);
        }
        if ((changes.type && !this.isTypeCircular) || (changes.categories && !this.isTypeCircular)) {
            this.svgContainerSize = {
                ...this.svgContainerSize,
                axisXLabelWidth: this.calculateAxisXLabelArea()
            };
        }
    }
    onSeriesClick(event) {
        this.seriesClick.emit(event);
    }
    onSeriesHover(event) {
        this.seriesHover.emit(event);
    }
    setDefaultHeight() {
        return poChartDefaultHeight;
    }
    transformObjectToArrayObject(serie) {
        this.chartSeries = typeof serie === 'object' && Object.keys(serie).length ? [{ ...serie }] : [];
    }
    setTypeDefault(serie) {
        const data = serie.data;
        const serieType = Object.values(PoChartType).includes(serie.type) ? serie.type : undefined;
        this.defaultType = serieType ? serieType : Array.isArray(data) ? PoChartType.Column : PoChartType.Pie;
    }
    validateSerieAndAddType(series) {
        const filteredSeries = series.filter(serie => this.isTypeCircular ? typeof serie.data === 'number' : Array.isArray(serie.data));
        this.chartSeries = this.appendType(this.appendColors(filteredSeries));
    }
    appendColors(series) {
        return this.colorService.getColors(series);
    }
    appendType(series) {
        return series.map((serie, index) => {
            if (index === 0) {
                this.chartType = Object.values(PoChartType).includes(serie.type)
                    ? serie.type
                    : this.type || this.defaultType;
            }
            return { ...serie, type: serie.type || this.chartType };
        });
    }
    static ɵfac = function PoChartBaseComponent_Factory(t) { return new (t || PoChartBaseComponent)(i0.ɵɵdirectiveInject(i1.PoColorService)); };
    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: PoChartBaseComponent, inputs: { title: [i0.ɵɵInputFlags.None, "p-title", "title"], height: [i0.ɵɵInputFlags.None, "p-height", "height"], type: [i0.ɵɵInputFlags.None, "p-type", "type"], series: [i0.ɵɵInputFlags.None, "p-series", "series"], categories: [i0.ɵɵInputFlags.None, "p-categories", "categories"], options: [i0.ɵɵInputFlags.None, "p-options", "options"] }, outputs: { seriesClick: "p-series-click", seriesHover: "p-series-hover" }, features: [i0.ɵɵNgOnChangesFeature] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PoChartBaseComponent, [{
        type: Directive
    }], () => [{ type: i1.PoColorService }], { title: [{
            type: Input,
            args: ['p-title']
        }], seriesClick: [{
            type: Output,
            args: ['p-series-click']
        }], seriesHover: [{
            type: Output,
            args: ['p-series-hover']
        }], height: [{
            type: Input,
            args: ['p-height']
        }], type: [{
            type: Input,
            args: ['p-type']
        }], series: [{
            type: Input,
            args: ['p-series']
        }], categories: [{
            type: Input,
            args: ['p-categories']
        }], options: [{
            type: Input,
            args: ['p-options']
        }] }); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tY2hhcnQtYmFzZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy91aS9zcmMvbGliL2NvbXBvbmVudHMvcG8tY2hhcnQvcG8tY2hhcnQtYmFzZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBNEIsTUFBTSxlQUFlLENBQUM7QUFFakcsT0FBTyxFQUFFLFlBQVksRUFBRSxRQUFRLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUcxRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7OztBQUt6RCxNQUFNLG9CQUFvQixHQUFHLEdBQUcsQ0FBQztBQUNqQyxNQUFNLGdCQUFnQixHQUFHLEdBQUcsQ0FBQztBQUU3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFFSCxNQUFNLE9BQWdCLG9CQUFvQjtJQW9MbEI7SUFuTHRCLGtDQUFrQztJQUNoQixLQUFLLENBQVU7SUFFakM7Ozs7Ozs7Ozs7T0FVRztJQUVILFdBQVcsR0FBRyxJQUFJLFlBQVksRUFBZ0IsQ0FBQztJQUUvQzs7Ozs7Ozs7OztPQVVHO0lBRUgsV0FBVyxHQUFHLElBQUksWUFBWSxFQUFnQixDQUFDO0lBRS9DLDBFQUEwRTtJQUMxRSxXQUFXLEdBQXdCLEVBQUUsQ0FBQztJQUN0QyxTQUFTLENBQWM7SUFDdkIsZ0JBQWdCLENBQXVCO0lBRS9CLFFBQVEsQ0FBaUI7SUFDekIsV0FBVyxDQUFnQjtJQUMzQixPQUFPLENBQVM7SUFDaEIsT0FBTyxDQUFzQjtJQUM3QixLQUFLLENBQWM7SUFFbkIsV0FBVyxDQUFjO0lBRWpDOzs7Ozs7Ozs7O09BVUc7SUFDSCxJQUF1QixNQUFNLENBQUMsS0FBYTtRQUN6QyxNQUFNLFFBQVEsR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckMsSUFBSSxN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QU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDakMsSUFBSSxLQUFLLEtBQUssQ0FBQyxFQUFFO2dCQUNmLElBQUksQ0FBQyxTQUFTLEdBQVMsTUFBTyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztvQkFDckUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJO29CQUNaLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUM7YUFDbkM7WUFFRCxPQUFPLEVBQUUsR0FBRyxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQzFELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs4RUExUG1CLG9CQUFvQjs2REFBcEIsb0JBQW9COztpRkFBcEIsb0JBQW9CO2NBRHpDLFNBQVM7K0NBR1UsS0FBSztrQkFBdEIsS0FBSzttQkFBQyxTQUFTO1lBY2hCLFdBQVc7a0JBRFYsTUFBTTttQkFBQyxnQkFBZ0I7WUFleEIsV0FBVztrQkFEVixNQUFNO21CQUFDLGdCQUFnQjtZQTJCRCxNQUFNO2tCQUE1QixLQUFLO21CQUFDLFVBQVU7WUFxQ0ksSUFBSTtrQkFBeEIsS0FBSzttQkFBQyxRQUFRO1lBZ0JRLE1BQU07a0JBQTVCLEtBQUs7bUJBQUMsVUFBVTtZQTBCVSxVQUFVO2tCQUFwQyxLQUFLO21CQUFDLGNBQWM7WUErQkcsT0FBTztrQkFBOUIsS0FBSzttQkFBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBEaXJlY3RpdmUsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBjb252ZXJ0VG9JbnQsIGlzVHlwZW9mIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbCc7XG5cbmltcG9ydCB7IFBvQ2hhcnRDb250YWluZXJTaXplIH0gZnJvbSAnLi9pbnRlcmZhY2VzL3BvLWNoYXJ0LWNvbnRhaW5lci1zaXplLmludGVyZmFjZSc7XG5pbXBvcnQgeyBQb0NoYXJ0VHlwZSB9IGZyb20gJy4vZW51bXMvcG8tY2hhcnQtdHlwZS5lbnVtJztcbmltcG9ydCB7IFBvQ2hhcnRPcHRpb25zIH0gZnJvbSAnLi9pbnRlcmZhY2VzL3BvLWNoYXJ0LW9wdGlvbnMuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBvQ2hhcnRTZXJpZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9wby1jaGFydC1zZXJpZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUG9Db2xvclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9wby1jb2xvci9wby1jb2xvci5zZXJ2aWNlJztcblxuY29uc3QgcG9DaGFydERlZmF1bHRIZWlnaHQgPSA0MDA7XG5jb25zdCBwb0NoYXJ0TWluSGVpZ2h0ID0gMjAwO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIE8gYHBvLWNoYXJ0YCDDqSB1bSBjb21wb25lbnRlIHBhcmEgcmVuZGVyaXphw6fDo28gZGUgZGFkb3MgYXRyYXbDqXMgZGUgZ3LDoWZpY29zLCBjb20gaXNzbyBmYWNpbGl0YW5kbyBhIGNvbXByZWVuc8OjbyBlIHRvcm5hbmRvIGFcbiAqIHZpc3VhbGl6YcOnw6NvIGRlc3RlcyBkYWRvcyBtYWlzIGFncmFkw6F2ZWwuXG4gKlxuICogQXRyYXbDqXMgZGUgc3VhcyBwcmluY2lwYWlzIHByb3ByaWVkYWRlcyDDqSBwb3Nzw612ZWwgZGVmaW5pciBhdHJpYnV0b3MsIHRhaXMgY29tbyB0aXBvIGRlIGdyw6FmaWNvLCBhbHR1cmEsIHTDrXR1bG8sIGNvcmVzIGN1c3RvbWl6YWRhcywgb3DDp8O1ZXMgcGFyYSBvcyBlaXhvcywgZW50cmUgb3V0cm9zLlxuICpcbiAqIE8gY29tcG9uZW50ZSBwZXJtaXRlIHV0aWxpemFyIGVtIGNvbmp1bnRvIHPDqXJpZXMgZG8gdGlwbyBsaW5oYSBlIGNvbHVuYS5cbiAqXG4gKiBBbMOpbSBkaXNzbywgdGFtYsOpbSDDqSBwb3Nzw612ZWwgZGVmaW5pciB1bWEgYcOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgYW8gY2xpY2FyIGVtIGRldGVybWluYWRvIGVsZW1lbnRvIGRvIGdyw6FmaWNvXG4gKiBlIG91dHJhIHF1ZSBzZXLDoSBleGVjdXRhZGEgYW8gcGFzc2FyIG8gKm1vdXNlKiBzb2JyZSBvIGVsZW1lbnRvLlxuICpcbiAqICMjIyMgR3VpYSBkZSB1c28gcGFyYSBHcsOhZmljb3NcbiAqXG4gKiA+IFZlamEgbm9zc28gW2d1aWEgZGUgdXNvIHBhcmEgZ3LDoWZpY29zXSgvZ3VpZGVzL2d1aWRlLWNoYXJ0cykgcGFyYSBhdXhpbGlhciBuYSBjb25zdHJ1w6fDo28gZG8gc2V1IGdyw6FmaWNvLFxuICogaW5mb3JtYW5kbyBlbSBxdWFsIGNhc28gdXRpbGl6YXIsIG8gcXVlIGRldmVtb3MgZXZpdGFyIGUgYm9hcyBwcsOhdGljYXMgcmVsYWNpb25hZGEgYSBjb3Jlcy5cbiAqL1xuQERpcmVjdGl2ZSgpXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUG9DaGFydEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICAvKiogRGVmaW5lIG8gdMOtdHVsbyBkbyBncsOhZmljby4gKi9cbiAgQElucHV0KCdwLXRpdGxlJykgdGl0bGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRXZlbnRvIGV4ZWN1dGFkbyBxdWFuZG8gbyB1c3XDoXJpbyBjbGljYXIgc29icmUgdW0gZWxlbWVudG8gZG8gZ3LDoWZpY28uXG4gICAqXG4gICAqIE8gZXZlbnRvIGVtaXRpcsOhIG8gc2VndWludGUgcGFyw6JtZXRybzpcbiAgICogLSAqZG9udXQqIGUgKnBpZSo6IHVtIG9iamV0byBjb250ZW5kbyBhIGNhdGVnb3JpYSBlIHZhbG9yIGRhIHPDqXJpZS5cbiAgICogLSAqYXJlYSosICpsaW5lKiwgKmNvbHVtbiogZSAqYmFyKjogdW0gb2JqZXRvIGNvbnRlbmRvIG8gbm9tZSBkYSBzw6lyaWUsIHZhbG9yIGUgY2F0ZWdvcmlhIGRvIGVpeG8gZG8gZ3LDoWZpY28uXG4gICAqL1xuICBAT3V0cHV0KCdwLXNlcmllcy1jbGljaycpXG4gIHNlcmllc0NsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxQb0NoYXJ0U2VyaWU+KCk7XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRXZlbnRvIGV4ZWN1dGFkbyBxdWFuZG8gbyB1c3XDoXJpbyBwYXNzYXIgbyAqbW91c2UqIHNvYnJlIHVtIGVsZW1lbnRvIGRvIGdyw6FmaWNvLlxuICAgKlxuICAgKiBPIGV2ZW50byBlbWl0aXLDoSBvIHNlZ3VpbnRlIHBhcsOibWV0cm8gZGUgYWNvcmRvIGNvbSBvIHRpcG8gZGUgZ3LDoWZpY286XG4gICAqIC0gKmRvbnV0KiBlICpwaWUqOiB1bSBvYmpldG8gY29udGVuZG8gYSBjYXRlZ29yaWEgZSB2YWxvciBkYSBzw6lyaWUuXG4gICAqIC0gKmFyZWEqLCAqbGluZSosICpjb2x1bW4qIGUgKmJhcio6IHVtIG9iamV0byBjb250ZW5kbyBhIGNhdGVnb3JpYSwgdmFsb3IgZGEgc8OpcmllIGUgY2F0ZWdvcmlhIGRvIGVpeG8gZG8gZ3LDoWZpY28uXG4gICAqL1xuICBAT3V0cHV0KCdwLXNlcmllcy1ob3ZlcicpXG4gIHNlcmllc0hvdmVyID0gbmV3IEV2ZW50RW1pdHRlcjxQb0NoYXJ0U2VyaWU+KCk7XG5cbiAgLy8gbWFuaXB1bGHDp8OjbyBkYXMgc8OpcmllcyB0cmF0YWRhcyBpbnRlcm5hbWVudGUgcGFyYSBwcmVzZXJ2YXIgJ3Atc2VyaWVzJztcbiAgY2hhcnRTZXJpZXM6IEFycmF5PFBvQ2hhcnRTZXJpZT4gPSBbXTtcbiAgY2hhcnRUeXBlOiBQb0NoYXJ0VHlwZTtcbiAgc3ZnQ29udGFpbmVyU2l6ZTogUG9DaGFydENvbnRhaW5lclNpemU7XG5cbiAgcHJpdmF0ZSBfb3B0aW9uczogUG9DaGFydE9wdGlvbnM7XG4gIHByaXZhdGUgX2NhdGVnb3JpZXM6IEFycmF5PHN0cmluZz47XG4gIHByaXZhdGUgX2hlaWdodDogbnVtYmVyO1xuICBwcml2YXRlIF9zZXJpZXM6IEFycmF5PFBvQ2hhcnRTZXJpZT47XG4gIHByaXZhdGUgX3R5cGU6IFBvQ2hhcnRUeXBlO1xuXG4gIHByaXZhdGUgZGVmYXVsdFR5cGU6IFBvQ2hhcnRUeXBlO1xuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERlZmluZSBhIGFsdHVyYSBkbyBncsOhZmljby5cbiAgICpcbiAgICogPiBPIHZhbG9yIG3DrW5pbW8gYWNlaXRvIG5lc3RhIHByb3ByaWVkYWRlIMOpIDIwMC5cbiAgICpcbiAgICogQGRlZmF1bHQgYDQwMHB4YFxuICAgKi9cbiAgQElucHV0KCdwLWhlaWdodCcpIHNldCBoZWlnaHQodmFsdWU6IG51bWJlcikge1xuICAgIGNvbnN0IGludFZhbHVlID0gY29udmVydFRvSW50KHZhbHVlKTtcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XG5cbiAgICBpZiAoaXNUeXBlb2YodmFsdWUsICdudW1iZXInKSkge1xuICAgICAgaGVpZ2h0ID0gaW50VmFsdWUgPD0gcG9DaGFydE1pbkhlaWdodCA/IHBvQ2hhcnRNaW5IZWlnaHQgOiBpbnRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gdGhpcy5zZXREZWZhdWx0SGVpZ2h0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5nZXRTdmdDb250YWluZXJTaXplKCk7XG4gICAgdGhpcy5yZWJ1aWxkQ29tcG9uZW50UmVmKCk7XG4gIH1cblxuICBnZXQgaGVpZ2h0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodCB8fCB0aGlzLnNldERlZmF1bHRIZWlnaHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERlZmluZSBvIHRpcG8gZGUgZ3LDoWZpY28uXG4gICAqXG4gICAqIMOJIHBvc3PDrXZlbCB0YW1iw6ltIGNvbWJpbmFyIGdyw6FmaWNvcyBkb3MgdGlwb3MgbGluaGEgZSBjb2x1bmEuIFBhcmEgaXNzbywgb3B0ZSBwZWxhIGRlY2xhcmHDp8OjbyBkZSBgdHlwZWAgY29uZm9ybWUgYSBpbnRlcmZhY2UgYFBvQ2hhcnRTZXJpZWAuXG4gICAqXG4gICAqID4gTm90ZSBxdWUsIHNlIGhvdXZlciBkZWNsYXJhw6fDo28gZGUgdGlwbyBkZSBncsOhZmljbyB0YW50byBlbSBgcC10eXBlYCBxdWFudG8gZW0gYFBvY2hhcnRTZXJpZS50eXBlYCwgbyB2YWxvciBgeyB0eXBlIH1gIGRhIHByaW1laXJhIHPDqXJpZSBhbnVsYXLDoSBvIHZhbG9yIGRlZmluaWRvIGVtIGBwLXR5cGVgLlxuICAgKlxuICAgKiBTZSBuw6NvIHBhc3NhZG8gdmFsb3IsIG8gcGFkcsOjbyBzZXLDoSByZWxhdGl2byDDoCBwcmltZWlyYSBzw6lyaWUgcGFzc2FkYSBlbSBgcC1zZXJpZXNgOlxuICAgKiAtIFNlIGBwLXNlcmllcyA9IFt7IGRhdGE6IFsxLDIsM10gfV1gOiBzZXLDoSBgUG9DaGFydFR5cGUuQ29sdW1uYC5cbiAgICogLSBTZSBgcC1zZXJpZXMgPSBbeyBkYXRhOiAxIH1dYDogc2Vyw6EgYFBvQ2hhcnRUeXBlLlBpZWAuXG4gICAqXG4gICAqID4gVmVqYSBvcyB2YWxvcmVzIHbDoWxpZG9zIG5vICplbnVtKiBgUG9DaGFydFR5cGVgLlxuICAgKi9cbiAgQElucHV0KCdwLXR5cGUnKSBzZXQgdHlwZSh2YWx1ZTogUG9DaGFydFR5cGUpIHtcbiAgICAvLyBPIFZhbG9yIGRlZmF1bHQgZGVmaW5pZG8gZW0gYHAtc2VyaWVzYCBkZSBhY29yZG8gY29tIGEgcHJpbWVpcmEgc8OpcmllIHBhc3NhZGEuXG4gICAgdGhpcy5fdHlwZSA9ICg8YW55Pk9iamVjdCkudmFsdWVzKFBvQ2hhcnRUeXBlKS5pbmNsdWRlcyh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcblxuICAgIHRoaXMucmVidWlsZENvbXBvbmVudFJlZigpO1xuICB9XG5cbiAgZ2V0IHR5cGUoKTogUG9DaGFydFR5cGUge1xuICAgIHJldHVybiB0aGlzLl90eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBEZWZpbmUgb3MgZWxlbWVudG9zIGRvIGdyw6FmaWNvIHF1ZSBzZXLDo28gY3JpYWRvcyBkaW5hbWljYW1lbnRlLlxuICAgKi9cbiAgQElucHV0KCdwLXNlcmllcycpIHNldCBzZXJpZXModmFsdWU6IEFycmF5PFBvQ2hhcnRTZXJpZT4pIHtcbiAgICB0aGlzLl9zZXJpZXMgPSB2YWx1ZSB8fCBbXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX3NlcmllcykgJiYgdGhpcy5fc2VyaWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5zZXRUeXBlRGVmYXVsdCh0aGlzLl9zZXJpZXNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybU9iamVjdFRvQXJyYXlPYmplY3QodGhpcy5zZXJpZXMpO1xuICAgICAgdGhpcy5yZWJ1aWxkQ29tcG9uZW50UmVmKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHNlcmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VyaWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRGVmaW5lIG9zIG5vbWVzIGRhcyBjYXRlZ29yaWFzIHF1ZSBzZXLDo28gcGxvdGFkYXMgbm8gZWl4byBYIGRvIGdyw6FmaWNvIGNhc28gc2VqYSBkbyB0aXBvIGBiYXJgLCBvdSBlbnTDo28gbm9zIGVpeG9zIFkgZG8gZ3JpZCBkZSBncsOhZmljb3MgZG9zIHRpcG9zIGBhcmVhYCwgYGNvbHVtbm5gIGUgYGxpbmVgLlxuICAgKlxuICAgKiA+IEdyw6FmaWNvcyBkbyB0aXBvIGBiYXJgIGRpbWVuc2lvbmFtIGEgw6FyZWEgZG8gZ3LDoWZpY28gZGUgYWNvcmRvIGNvbSBhIGxhcmd1cmEgZG8gbWFpb3IgdGV4dG8gZGUgY2F0ZWdvcmlhcy4gTm8gZW50YW50bywgw6kgdW1hIGJvYSBwcsOhdGljYSBvcHRhciBwb3IgcGFsYXZyYXMgY3VydGFzIHBhcmEgcXVlIGEgbGVpdHVyYSBkbyBncsOhZmljbyBuw6NvIHNlamEgcHJlanVkaWNhZGEuXG4gICAqXG4gICAqID4gQ2FzbyBuw6NvIHNlamEgZXNwZWNpZmljYWRvIHVtIHZhbG9yIHBhcmEgYSBjYXRlZ29yaWEsIHNlcsOhIHBsb3RhZG8gdW0gaMOtZmVuIG5hIGNhdGVnb3JpYSByZWZlcmVudGUgYSBjYWRhIHPDqXJpZS5cbiAgICovXG4gIEBJbnB1dCgncC1jYXRlZ29yaWVzJykgc2V0IGNhdGVnb3JpZXModmFsdWU6IEFycmF5PHN0cmluZz4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX2NhdGVnb3JpZXMgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBnZXQgY2F0ZWdvcmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2F0ZWdvcmllcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIE9iamV0byBjb20gYXMgY29uZmlndXJhw6fDtWVzIHVzYWRhcyBubyBgcG8tY2hhcnRgLlxuICAgKlxuICAgKiDDiSBwb3Nzw612ZWwsIHBvciBleGVtcGxvLCBkZWZpbmlyIGFzIGNvbmZpZ3VyYcOnw7VlcyBkZSBleGliacOnw6NvIGRhcyBsZWdlbmRhcyxcbiAgICogY29uZmlndXJhciBvcyBlaXhvcygqYXhpcyopIHBhcmEgb3MgZ3LDoWZpY29zIGRvcyB0aXBvcyBgYXJlYWAsIGBsaW5lYCwgYGNvbHVtbmAgZSBgYmFyYCBkYSBzZWd1aW50ZSBmb3JtYTpcbiAgICpcbiAgICogYGBgXG4gICAqICBjaGFydE9wdGlvbnM6IFBvQ2hhcnRPcHRpb25zID0ge1xuICAgKiAgICBsZWdlbmQ6IHRydWUsXG4gICAqICAgIGF4aXM6IHtcbiAgICogICAgICBtaW5SYW5nZTogMCxcbiAgICogICAgICBtYXhSYW5nZTogMTAwLFxuICAgKiAgICAgIGdyaWRMaW5lczogNSxcbiAgICogICAgfSxcbiAgICogIH07XG4gICAqIGBgYFxuICAgKi9cbiAgQElucHV0KCdwLW9wdGlvbnMnKSBzZXQgb3B0aW9ucyh2YWx1ZTogUG9DaGFydE9wdGlvbnMpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdGhpcy5fb3B0aW9ucyA9IHZhbHVlO1xuXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbGVnZW5kJykgJiYgdHlwZW9mIHRoaXMuX29wdGlvbnMubGVnZW5kID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5nZXRTdmdDb250YWluZXJTaXplKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgY29sb3JTZXJ2aWNlOiBQb0NvbG9yU2VydmljZSkge31cblxuICBnZXQgaXNUeXBlQ2lyY3VsYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFR5cGUgPT09IFBvQ2hhcnRUeXBlLlBpZSB8fCB0aGlzLmRlZmF1bHRUeXBlID09PSBQb0NoYXJ0VHlwZS5Eb251dDtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBjb25zdCBpc0FycmF5T2ZzZXJpZXMgPSBBcnJheS5pc0FycmF5KHRoaXMuc2VyaWVzKSAmJiB0aGlzLnNlcmllcy5sZW5ndGggPiAwO1xuXG4gICAgaWYgKFxuICAgICAgKGNoYW5nZXMuc2VyaWVzICYmIGlzQXJyYXlPZnNlcmllcykgfHxcbiAgICAgIChjaGFuZ2VzLnR5cGUgJiYgaXNBcnJheU9mc2VyaWVzKSB8fFxuICAgICAgKGNoYW5nZXMuY2F0ZWdvcmllcyAmJiBpc0FycmF5T2ZzZXJpZXMpXG4gICAgKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlU2VyaWVBbmRBZGRUeXBlKHRoaXMuc2VyaWVzKTtcbiAgICB9XG5cbiAgICBpZiAoKGNoYW5nZXMudHlwZSAmJiAhdGhpcy5pc1R5cGVDaXJjdWxhcikgfHwgKGNoYW5nZXMuY2F0ZWdvcmllcyAmJiAhdGhpcy5pc1R5cGVDaXJjdWxhcikpIHtcbiAgICAgIHRoaXMuc3ZnQ29udGFpbmVyU2l6ZSA9IHtcbiAgICAgICAgLi4udGhpcy5zdmdDb250YWluZXJTaXplLFxuICAgICAgICBheGlzWExhYmVsV2lkdGg6IHRoaXMuY2FsY3VsYXRlQXhpc1hMYWJlbEFyZWEoKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBvblNlcmllc0NsaWNrKGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLnNlcmllc0NsaWNrLmVtaXQoZXZlbnQpO1xuICB9XG5cbiAgb25TZXJpZXNIb3ZlcihldmVudDogYW55KTogdm9pZCB7XG4gICAgdGhpcy5zZXJpZXNIb3Zlci5lbWl0KGV2ZW50KTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0RGVmYXVsdEhlaWdodCgpIHtcbiAgICByZXR1cm4gcG9DaGFydERlZmF1bHRIZWlnaHQ7XG4gIH1cblxuICBwcml2YXRlIHRyYW5zZm9ybU9iamVjdFRvQXJyYXlPYmplY3Qoc2VyaWUpIHtcbiAgICB0aGlzLmNoYXJ0U2VyaWVzID0gdHlwZW9mIHNlcmllID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhzZXJpZSkubGVuZ3RoID8gW3sgLi4uc2VyaWUgfV0gOiBbXTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0VHlwZURlZmF1bHQoc2VyaWU6IFBvQ2hhcnRTZXJpZSkge1xuICAgIGNvbnN0IGRhdGEgPSBzZXJpZS5kYXRhO1xuICAgIGNvbnN0IHNlcmllVHlwZSA9ICg8YW55Pk9iamVjdCkudmFsdWVzKFBvQ2hhcnRUeXBlKS5pbmNsdWRlcyhzZXJpZS50eXBlKSA/IHNlcmllLnR5cGUgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmRlZmF1bHRUeXBlID0gc2VyaWVUeXBlID8gc2VyaWVUeXBlIDogQXJyYXkuaXNBcnJheShkYXRhKSA/IFBvQ2hhcnRUeXBlLkNvbHVtbiA6IFBvQ2hhcnRUeXBlLlBpZTtcbiAgfVxuXG4gIHByaXZhdGUgdmFsaWRhdGVTZXJpZUFuZEFkZFR5cGUoc2VyaWVzOiBBcnJheTxQb0NoYXJ0U2VyaWU+KTogdm9pZCB7XG4gICAgY29uc3QgZmlsdGVyZWRTZXJpZXMgPSBzZXJpZXMuZmlsdGVyKHNlcmllID0+XG4gICAgICB0aGlzLmlzVHlwZUNpcmN1bGFyID8gdHlwZW9mIHNlcmllLmRhdGEgPT09ICdudW1iZXInIDogQXJyYXkuaXNBcnJheShzZXJpZS5kYXRhKVxuICAgICk7XG5cbiAgICB0aGlzLmNoYXJ0U2VyaWVzID0gdGhpcy5hcHBlbmRUeXBlKHRoaXMuYXBwZW5kQ29sb3JzKGZpbHRlcmVkU2VyaWVzKSk7XG4gIH1cblxuICBwcml2YXRlIGFwcGVuZENvbG9ycyhzZXJpZXM6IEFycmF5PFBvQ2hhcnRTZXJpZT4pIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclNlcnZpY2UuZ2V0Q29sb3JzPFBvQ2hhcnRTZXJpZT4oc2VyaWVzKTtcbiAgfVxuXG4gIHByaXZhdGUgYXBwZW5kVHlwZShzZXJpZXM6IEFycmF5PFBvQ2hhcnRTZXJpZT4pIHtcbiAgICByZXR1cm4gc2VyaWVzLm1hcCgoc2VyaWUsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSAoPGFueT5PYmplY3QpLnZhbHVlcyhQb0NoYXJ0VHlwZSkuaW5jbHVkZXMoc2VyaWUudHlwZSlcbiAgICAgICAgICA/IHNlcmllLnR5cGVcbiAgICAgICAgICA6IHRoaXMudHlwZSB8fCB0aGlzLmRlZmF1bHRUeXBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyAuLi5zZXJpZSwgdHlwZTogc2VyaWUudHlwZSB8fCB0aGlzLmNoYXJ0VHlwZSB9O1xuICAgIH0pO1xuICB9XG5cbiAgYWJzdHJhY3QgcmVidWlsZENvbXBvbmVudFJlZigpOiB2b2lkO1xuXG4gIC8vIHbDoWxpZG8gcGFyYSBncsOhZmljb3MgZG8gdGlwbyBjaXJjdWxhciBlIHF1ZSBzZXLDoSByZWZhdG9yYWRvLlxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0U3ZnQ29udGFpbmVyU2l6ZSgpOiB2b2lkO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgY2FsY3VsYXRlQXhpc1hMYWJlbEFyZWEoKTogbnVtYmVyO1xufVxuIl19