import { Injectable } from '@angular/core';
import { PoChartGridLines } from '../helpers/po-chart-default-values.constant';
import { PoChartType } from '../enums/po-chart-type.enum';
import * as i0 from "@angular/core";
export class PoChartMathsService {
    /**
     * Calcula e retorna os válores mínimo e máximo das séries.
     *
     * @param series Lista de séries.
     * @param acceptNegativeValues boolean.
     */
    calculateMinAndMaxValues(series, acceptNegativeValues = true) {
        const minValue = this.getDomain(series, 'min');
        const maxValue = this.getDomain(series, 'max');
        return {
            minValue: !acceptNegativeValues && minValue < 0 ? 0 : minValue,
            maxValue: acceptNegativeValues && maxValue < 0 ? 0 : maxValue
        };
    }
    /**
     * Retorna o valor com maior quantidade de dígitos entre todas as séries.
     * Pode receber uma lista de categorias para o caso de gráfico de barra, ou então a lista de séries se o tipo de gráfico for linha ou coluna.
     *
     * @param data Lista de séries.
     * @param type O tipo do gráfico'.
     * @param options As opções para validação de número de linhas do eixo X'.
     */
    getLongestDataValue(data = [], type, options) {
        if (type === PoChartType.Bar) {
            return this.getLongestData(data);
        }
        else {
            return this.getAxisXLabelLongestValue(data, this.amountOfGridLines(options?.axis));
        }
    }
    /**
     * Retorna o tamanho da série que tiver mais itens.
     *
     * @param series Lista de séries.
     */
    seriesGreaterLength(series) {
        return series.reduce((result, serie) => (result > serie.data.length ? result : serie.data.length), 0);
    }
    /**
     * Retorna o percentual em decimal da série passada pela distância entre os valores mínimos e máximos da série.
     *
     * Se o valor mínimo for negativo o alcance partirá dele como sendo zero %.
     *
     * Por exemplo:
     *    minValue = -10;
     *    maxValue = 0;
     *    serieValue = -8
     *    O resultado será de 0.20;
     *
     * @param minMaxValues Objeto contendo os valores mínimo e máximo de todas as séries.
     * @param serieValue O valor da série.
     */
    getSeriePercentage(minMaxValues, serieValue) {
        const { minValue, maxValue } = minMaxValues;
        const range = maxValue - minValue;
        const displacement = serieValue - minValue;
        const result = displacement / range;
        return isNaN(result) ? 0 : result;
    }
    /**
     * Calcula e retorna uma lista de valores referentes aos textos dos eixos X em relação à quantidade de linhas horizontais.
     *
     * @param minMaxValues Objeto contendo os valores mínimo e máximo de todas as séries.
     * @param gridLines Quantidade de linhas horizontais. Valor default é 5.
     */
    range(minMaxValues, gridLines = 5) {
        const { minValue, maxValue } = minMaxValues;
        const result = [];
        const step = this.getGridLineArea(minMaxValues, gridLines);
        for (let index = minValue; index <= maxValue; index = (index * 10 + step * 10) / 10) {
            result.push(index);
        }
        return result;
    }
    /**
     *
     * Verifica se o valor passado é um Integer ou Float.
     *
     * @param number O valor a ser validado
     */
    verifyIfFloatOrInteger(number) {
        const notABoolean = typeof number !== 'boolean';
        const notInfinity = number !== Infinity;
        const isInteger = Number(number) === number && number % 1 === 0 && notInfinity;
        const isFloat = Number(number) === number && number % 1 !== 0 && notInfinity;
        return (notABoolean && isInteger) || (notABoolean && isFloat);
    }
    amountOfGridLines(options) {
        const gridLines = options?.gridLines ?? PoChartGridLines;
        return gridLines && gridLines >= 2 && gridLines <= 10 ? gridLines : PoChartGridLines;
    }
    getAxisXLabelLongestValue(data, gridLines) {
        const allowNegativeData = data.every(dataItem => dataItem.type === PoChartType.Line);
        const domain = this.calculateMinAndMaxValues(data, allowNegativeData);
        const axisXLabelsList = this.range(domain, gridLines);
        return this.getLongestData(axisXLabelsList);
    }
    // Cálculo que retorna o valor obtido de gridLines em relação ao alcance dos valores mínimos e máximos das séries (maxMinValues)
    getGridLineArea(minMaxValues, gridLines) {
        const percentageValue = this.getFractionFromInt(gridLines - 1);
        const { minValue, maxValue } = minMaxValues;
        const result = (percentageValue * (maxValue - minValue)) / 100;
        return result === 0 ? 1 : result;
    }
    // Retorna o valor máximo ou mínimo das séries baseado no tipo passado(type).
    getDomain(series, type) {
        const result = Math[type](...series.map(serie => {
            if (Array.isArray(serie.data)) {
                return Math[type](...serie.data);
            }
        }));
        return isNaN(result) ? 0 : result;
    }
    // Retorna a fração do número passado referente à quantidade de linhas no eixo X (gridLines)
    getFractionFromInt(value) {
        return (1 / value) * (100 / 1);
    }
    getLongestData(serie) {
        const newSerie = [...serie];
        return newSerie.sort((longest, current) => current.toString().length - longest.toString().length)['0'];
    }
    static ɵfac = function PoChartMathsService_Factory(t) { return new (t || PoChartMathsService)(); };
    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: PoChartMathsService, factory: PoChartMathsService.ɵfac, providedIn: 'root' });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PoChartMathsService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tY2hhcnQtbWF0aHMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3VpL3NyYy9saWIvY29tcG9uZW50cy9wby1jaGFydC9zZXJ2aWNlcy9wby1jaGFydC1tYXRocy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFDL0UsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLDZCQUE2QixDQUFDOztBQVUxRCxNQUFNLE9BQU8sbUJBQW1CO0lBQzlCOzs7OztPQUtHO0lBQ0gsd0JBQXdCLENBQUMsTUFBa0IsRUFBRSx1QkFBZ0MsSUFBSTtRQUMvRSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUMvQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUUvQyxPQUFPO1lBQ0wsUUFBUSxFQUFFLENBQUMsb0JBQW9CLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRO1lBQzlELFFBQVEsRUFBRSxvQkFBb0IsSUFBSSxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVE7U0FDOUQsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsbUJBQW1CLENBQ2pCLE9BQXFDLEVBQUUsRUFDdkMsSUFBaUIsRUFDakIsT0FBdUI7UUFFdkIsSUFBSSxJQUFJLEtBQUssV0FBVyxDQUFDLEdBQUcsRUFBRTtZQUM1QixPQUFPLElBQUksQ0FBQyxjQUFjLENBQVMsSUFBcUIsQ0FBQyxDQUFDO1NBQzNE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RCw0RkFBNEY7SUFDcEYsa0JBQWtCLENBQUMsS0FBYTtRQUN0QyxPQUFPLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFTyxjQUFjLENBQUksS0FBZTtRQUN2QyxNQUFNLFFBQVEsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7UUFDNUIsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDekcsQ0FBQzs2RUFwSlUsbUJBQW1CO2dFQUFuQixtQkFBbUIsV0FBbkIsbUJBQW1CLG1CQUZsQixNQUFNOztpRkFFUCxtQkFBbUI7Y0FIL0IsVUFBVTtlQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQb0NoYXJ0R3JpZExpbmVzIH0gZnJvbSAnLi4vaGVscGVycy9wby1jaGFydC1kZWZhdWx0LXZhbHVlcy5jb25zdGFudCc7XG5pbXBvcnQgeyBQb0NoYXJ0VHlwZSB9IGZyb20gJy4uL2VudW1zL3BvLWNoYXJ0LXR5cGUuZW51bSc7XG5cbmltcG9ydCB7IFBvQ2hhcnRBeGlzT3B0aW9ucyB9IGZyb20gJy4uL2ludGVyZmFjZXMvcG8tY2hhcnQtYXhpcy1vcHRpb25zLmludGVyZmFjZSc7XG5pbXBvcnQgeyBQb0NoYXJ0TWluTWF4VmFsdWVzIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9wby1jaGFydC1taW4tbWF4LXZhbHVlcy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUG9DaGFydE9wdGlvbnMgfSBmcm9tICcuLi9pbnRlcmZhY2VzL3BvLWNoYXJ0LW9wdGlvbnMuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBvQ2hhcnRTZXJpZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvcG8tY2hhcnQtc2VyaWUuaW50ZXJmYWNlJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgUG9DaGFydE1hdGhzU2VydmljZSB7XG4gIC8qKlxuICAgKiBDYWxjdWxhIGUgcmV0b3JuYSBvcyB2w6Fsb3JlcyBtw61uaW1vIGUgbcOheGltbyBkYXMgc8Opcmllcy5cbiAgICpcbiAgICogQHBhcmFtIHNlcmllcyBMaXN0YSBkZSBzw6lyaWVzLlxuICAgKiBAcGFyYW0gYWNjZXB0TmVnYXRpdmVWYWx1ZXMgYm9vbGVhbi5cbiAgICovXG4gIGNhbGN1bGF0ZU1pbkFuZE1heFZhbHVlcyhzZXJpZXM6IEFycmF5PGFueT4sIGFjY2VwdE5lZ2F0aXZlVmFsdWVzOiBib29sZWFuID0gdHJ1ZSk6IFBvQ2hhcnRNaW5NYXhWYWx1ZXMge1xuICAgIGNvbnN0IG1pblZhbHVlID0gdGhpcy5nZXREb21haW4oc2VyaWVzLCAnbWluJyk7XG4gICAgY29uc3QgbWF4VmFsdWUgPSB0aGlzLmdldERvbWFpbihzZXJpZXMsICdtYXgnKTtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW5WYWx1ZTogIWFjY2VwdE5lZ2F0aXZlVmFsdWVzICYmIG1pblZhbHVlIDwgMCA/IDAgOiBtaW5WYWx1ZSxcbiAgICAgIG1heFZhbHVlOiBhY2NlcHROZWdhdGl2ZVZhbHVlcyAmJiBtYXhWYWx1ZSA8IDAgPyAwIDogbWF4VmFsdWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldG9ybmEgbyB2YWxvciBjb20gbWFpb3IgcXVhbnRpZGFkZSBkZSBkw61naXRvcyBlbnRyZSB0b2RhcyBhcyBzw6lyaWVzLlxuICAgKiBQb2RlIHJlY2ViZXIgdW1hIGxpc3RhIGRlIGNhdGVnb3JpYXMgcGFyYSBvIGNhc28gZGUgZ3LDoWZpY28gZGUgYmFycmEsIG91IGVudMOjbyBhIGxpc3RhIGRlIHPDqXJpZXMgc2UgbyB0aXBvIGRlIGdyw6FmaWNvIGZvciBsaW5oYSBvdSBjb2x1bmEuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIExpc3RhIGRlIHPDqXJpZXMuXG4gICAqIEBwYXJhbSB0eXBlIE8gdGlwbyBkbyBncsOhZmljbycuXG4gICAqIEBwYXJhbSBvcHRpb25zIEFzIG9ww6fDtWVzIHBhcmEgdmFsaWRhw6fDo28gZGUgbsO6bWVybyBkZSBsaW5oYXMgZG8gZWl4byBYJy5cbiAgICovXG4gIGdldExvbmdlc3REYXRhVmFsdWUoXG4gICAgZGF0YTogQXJyYXk8UG9DaGFydFNlcmllIHwgc3RyaW5nPiA9IFtdLFxuICAgIHR5cGU6IFBvQ2hhcnRUeXBlLFxuICAgIG9wdGlvbnM6IFBvQ2hhcnRPcHRpb25zXG4gICk6IG51bWJlciB8IHN0cmluZyB7XG4gICAgaWYgKHR5cGUgPT09IFBvQ2hhcnRUeXBlLkJhcikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9uZ2VzdERhdGE8c3RyaW5nPihkYXRhIGFzIEFycmF5PHN0cmluZz4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBeGlzWExhYmVsTG9uZ2VzdFZhbHVlKGRhdGEgYXMgQXJyYXk8UG9DaGFydFNlcmllPiwgdGhpcy5hbW91bnRPZkdyaWRMaW5lcyhvcHRpb25zPy5heGlzKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldG9ybmEgbyB0YW1hbmhvIGRhIHPDqXJpZSBxdWUgdGl2ZXIgbWFpcyBpdGVucy5cbiAgICpcbiAgICogQHBhcmFtIHNlcmllcyBMaXN0YSBkZSBzw6lyaWVzLlxuICAgKi9cbiAgc2VyaWVzR3JlYXRlckxlbmd0aChzZXJpZXM6IEFycmF5PFBvQ2hhcnRTZXJpZT4pOiBudW1iZXIge1xuICAgIHJldHVybiBzZXJpZXMucmVkdWNlKChyZXN1bHQsIHNlcmllOiBhbnkpID0+IChyZXN1bHQgPiBzZXJpZS5kYXRhLmxlbmd0aCA/IHJlc3VsdCA6IHNlcmllLmRhdGEubGVuZ3RoKSwgMCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0b3JuYSBvIHBlcmNlbnR1YWwgZW0gZGVjaW1hbCBkYSBzw6lyaWUgcGFzc2FkYSBwZWxhIGRpc3TDom5jaWEgZW50cmUgb3MgdmFsb3JlcyBtw61uaW1vcyBlIG3DoXhpbW9zIGRhIHPDqXJpZS5cbiAgICpcbiAgICogU2UgbyB2YWxvciBtw61uaW1vIGZvciBuZWdhdGl2byBvIGFsY2FuY2UgcGFydGlyw6EgZGVsZSBjb21vIHNlbmRvIHplcm8gJS5cbiAgICpcbiAgICogUG9yIGV4ZW1wbG86XG4gICAqICAgIG1pblZhbHVlID0gLTEwO1xuICAgKiAgICBtYXhWYWx1ZSA9IDA7XG4gICAqICAgIHNlcmllVmFsdWUgPSAtOFxuICAgKiAgICBPIHJlc3VsdGFkbyBzZXLDoSBkZSAwLjIwO1xuICAgKlxuICAgKiBAcGFyYW0gbWluTWF4VmFsdWVzIE9iamV0byBjb250ZW5kbyBvcyB2YWxvcmVzIG3DrW5pbW8gZSBtw6F4aW1vIGRlIHRvZGFzIGFzIHPDqXJpZXMuXG4gICAqIEBwYXJhbSBzZXJpZVZhbHVlIE8gdmFsb3IgZGEgc8OpcmllLlxuICAgKi9cbiAgZ2V0U2VyaWVQZXJjZW50YWdlKG1pbk1heFZhbHVlczogYW55LCBzZXJpZVZhbHVlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgbWluVmFsdWUsIG1heFZhbHVlIH0gPSBtaW5NYXhWYWx1ZXM7XG5cbiAgICBjb25zdCByYW5nZSA9IG1heFZhbHVlIC0gbWluVmFsdWU7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gc2VyaWVWYWx1ZSAtIG1pblZhbHVlO1xuICAgIGNvbnN0IHJlc3VsdCA9IGRpc3BsYWNlbWVudCAvIHJhbmdlO1xuXG4gICAgcmV0dXJuIGlzTmFOKHJlc3VsdCkgPyAwIDogcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGEgZSByZXRvcm5hIHVtYSBsaXN0YSBkZSB2YWxvcmVzIHJlZmVyZW50ZXMgYW9zIHRleHRvcyBkb3MgZWl4b3MgWCBlbSByZWxhw6fDo28gw6AgcXVhbnRpZGFkZSBkZSBsaW5oYXMgaG9yaXpvbnRhaXMuXG4gICAqXG4gICAqIEBwYXJhbSBtaW5NYXhWYWx1ZXMgT2JqZXRvIGNvbnRlbmRvIG9zIHZhbG9yZXMgbcOtbmltbyBlIG3DoXhpbW8gZGUgdG9kYXMgYXMgc8Opcmllcy5cbiAgICogQHBhcmFtIGdyaWRMaW5lcyBRdWFudGlkYWRlIGRlIGxpbmhhcyBob3Jpem9udGFpcy4gVmFsb3IgZGVmYXVsdCDDqSA1LlxuICAgKi9cbiAgcmFuZ2UobWluTWF4VmFsdWVzOiBQb0NoYXJ0TWluTWF4VmFsdWVzLCBncmlkTGluZXM6IG51bWJlciA9IDUpIHtcbiAgICBjb25zdCB7IG1pblZhbHVlLCBtYXhWYWx1ZSB9ID0gbWluTWF4VmFsdWVzO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgc3RlcCA9IHRoaXMuZ2V0R3JpZExpbmVBcmVhKG1pbk1heFZhbHVlcywgZ3JpZExpbmVzKTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gbWluVmFsdWU7IGluZGV4IDw9IG1heFZhbHVlOyBpbmRleCA9IChpbmRleCAqIDEwICsgc3RlcCAqIDEwKSAvIDEwKSB7XG4gICAgICByZXN1bHQucHVzaChpbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBWZXJpZmljYSBzZSBvIHZhbG9yIHBhc3NhZG8gw6kgdW0gSW50ZWdlciBvdSBGbG9hdC5cbiAgICpcbiAgICogQHBhcmFtIG51bWJlciBPIHZhbG9yIGEgc2VyIHZhbGlkYWRvXG4gICAqL1xuICB2ZXJpZnlJZkZsb2F0T3JJbnRlZ2VyKG51bWJlcjogbnVtYmVyKSB7XG4gICAgY29uc3Qgbm90QUJvb2xlYW4gPSB0eXBlb2YgbnVtYmVyICE9PSAnYm9vbGVhbic7XG4gICAgY29uc3Qgbm90SW5maW5pdHkgPSBudW1iZXIgIT09IEluZmluaXR5O1xuXG4gICAgY29uc3QgaXNJbnRlZ2VyID0gTnVtYmVyKG51bWJlcikgPT09IG51bWJlciAmJiBudW1iZXIgJSAxID09PSAwICYmIG5vdEluZmluaXR5O1xuICAgIGNvbnN0IGlzRmxvYXQgPSBOdW1iZXIobnVtYmVyKSA9PT0gbnVtYmVyICYmIG51bWJlciAlIDEgIT09IDAgJiYgbm90SW5maW5pdHk7XG5cbiAgICByZXR1cm4gKG5vdEFCb29sZWFuICYmIGlzSW50ZWdlcikgfHwgKG5vdEFCb29sZWFuICYmIGlzRmxvYXQpO1xuICB9XG5cbiAgcHJpdmF0ZSBhbW91bnRPZkdyaWRMaW5lcyhvcHRpb25zOiBQb0NoYXJ0QXhpc09wdGlvbnMpOiBudW1iZXIge1xuICAgIGNvbnN0IGdyaWRMaW5lcyA9IG9wdGlvbnM/LmdyaWRMaW5lcyA/PyBQb0NoYXJ0R3JpZExpbmVzO1xuXG4gICAgcmV0dXJuIGdyaWRMaW5lcyAmJiBncmlkTGluZXMgPj0gMiAmJiBncmlkTGluZXMgPD0gMTAgPyBncmlkTGluZXMgOiBQb0NoYXJ0R3JpZExpbmVzO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBeGlzWExhYmVsTG9uZ2VzdFZhbHVlKGRhdGE6IEFycmF5PFBvQ2hhcnRTZXJpZT4sIGdyaWRMaW5lczogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBhbGxvd05lZ2F0aXZlRGF0YTogYm9vbGVhbiA9IGRhdGEuZXZlcnkoZGF0YUl0ZW0gPT4gZGF0YUl0ZW0udHlwZSA9PT0gUG9DaGFydFR5cGUuTGluZSk7XG4gICAgY29uc3QgZG9tYWluOiBQb0NoYXJ0TWluTWF4VmFsdWVzID0gdGhpcy5jYWxjdWxhdGVNaW5BbmRNYXhWYWx1ZXMoZGF0YSwgYWxsb3dOZWdhdGl2ZURhdGEpO1xuICAgIGNvbnN0IGF4aXNYTGFiZWxzTGlzdDogQXJyYXk8bnVtYmVyPiA9IHRoaXMucmFuZ2UoZG9tYWluLCBncmlkTGluZXMpO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0TG9uZ2VzdERhdGE8bnVtYmVyPihheGlzWExhYmVsc0xpc3QpO1xuICB9XG5cbiAgLy8gQ8OhbGN1bG8gcXVlIHJldG9ybmEgbyB2YWxvciBvYnRpZG8gZGUgZ3JpZExpbmVzIGVtIHJlbGHDp8OjbyBhbyBhbGNhbmNlIGRvcyB2YWxvcmVzIG3DrW5pbW9zIGUgbcOheGltb3MgZGFzIHPDqXJpZXMgKG1heE1pblZhbHVlcylcbiAgcHJpdmF0ZSBnZXRHcmlkTGluZUFyZWEobWluTWF4VmFsdWVzOiBQb0NoYXJ0TWluTWF4VmFsdWVzLCBncmlkTGluZXM6IG51bWJlcikge1xuICAgIGNvbnN0IHBlcmNlbnRhZ2VWYWx1ZSA9IHRoaXMuZ2V0RnJhY3Rpb25Gcm9tSW50KGdyaWRMaW5lcyAtIDEpO1xuICAgIGNvbnN0IHsgbWluVmFsdWUsIG1heFZhbHVlIH0gPSBtaW5NYXhWYWx1ZXM7XG4gICAgY29uc3QgcmVzdWx0ID0gKHBlcmNlbnRhZ2VWYWx1ZSAqIChtYXhWYWx1ZSAtIG1pblZhbHVlKSkgLyAxMDA7XG5cbiAgICByZXR1cm4gcmVzdWx0ID09PSAwID8gMSA6IHJlc3VsdDtcbiAgfVxuXG4gIC8vIFJldG9ybmEgbyB2YWxvciBtw6F4aW1vIG91IG3DrW5pbW8gZGFzIHPDqXJpZXMgYmFzZWFkbyBubyB0aXBvIHBhc3NhZG8odHlwZSkuXG4gIHByaXZhdGUgZ2V0RG9tYWluKHNlcmllczogQXJyYXk8YW55PiwgdHlwZTogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gTWF0aFt0eXBlXShcbiAgICAgIC4uLnNlcmllcy5tYXAoc2VyaWUgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXJpZS5kYXRhKSkge1xuICAgICAgICAgIHJldHVybiBNYXRoW3R5cGVdKC4uLnNlcmllLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIGlzTmFOKHJlc3VsdCkgPyAwIDogcmVzdWx0O1xuICB9XG5cbiAgLy8gUmV0b3JuYSBhIGZyYcOnw6NvIGRvIG7Dum1lcm8gcGFzc2FkbyByZWZlcmVudGUgw6AgcXVhbnRpZGFkZSBkZSBsaW5oYXMgbm8gZWl4byBYIChncmlkTGluZXMpXG4gIHByaXZhdGUgZ2V0RnJhY3Rpb25Gcm9tSW50KHZhbHVlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gKDEgLyB2YWx1ZSkgKiAoMTAwIC8gMSk7XG4gIH1cblxuICBwcml2YXRlIGdldExvbmdlc3REYXRhPFQ+KHNlcmllOiBBcnJheTxUPik6IFQge1xuICAgIGNvbnN0IG5ld1NlcmllID0gWy4uLnNlcmllXTtcbiAgICByZXR1cm4gbmV3U2VyaWUuc29ydCgobG9uZ2VzdCwgY3VycmVudCkgPT4gY3VycmVudC50b1N0cmluZygpLmxlbmd0aCAtIGxvbmdlc3QudG9TdHJpbmcoKS5sZW5ndGgpWycwJ107XG4gIH1cbn1cbiJdfQ==