/// <reference types="resize-observer-browser" />
/// <reference types="resize-observer-browser" />
import { Directive, EventEmitter, Output } from '@angular/core';
import { Subject, Subscription } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import * as i0 from "@angular/core";
export class PoResizeObserverDirective {
    elementRef;
    resize = new EventEmitter();
    subscription = new Subscription();
    observer;
    chartWidthResize$ = new Subject();
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
    ngOnDestroy() {
        if (this.isResizeObserverSupported) {
            this.observer.unobserve(this.elementRef.nativeElement);
            this.subscription.unsubscribe();
        }
    }
    ngOnInit() {
        if (this.isResizeObserverSupported) {
            this.observer = new window.ResizeObserver(() => {
                this.chartWidthResize$.next({});
            });
            this.observer.observe(this.elementRef.nativeElement);
            this.subscription.add(this.chartWidthResize$.pipe(debounceTime(20)).subscribe(_ => {
                this.resize.emit();
            }));
        }
    }
    get isResizeObserverSupported() {
        return typeof window.ResizeObserver === 'function';
    }
    static ɵfac = function PoResizeObserverDirective_Factory(t) { return new (t || PoResizeObserverDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };
    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: PoResizeObserverDirective, selectors: [["", "p-resize-observer", ""]], outputs: { resize: "p-resize-observer" } });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PoResizeObserverDirective, [{
        type: Directive,
        args: [{
                selector: '[p-resize-observer]'
            }]
    }], () => [{ type: i0.ElementRef }], { resize: [{
            type: Output,
            args: ['p-resize-observer']
        }] }); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tcmVzaXplLW9ic2VydmVyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3VpL3NyYy9saWIvY29tcG9uZW50cy9wby1jaGFydC9kaXJlY3RpdmVzL3BvLXJlc2l6ZS1vYnNlcnZlci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaURBQWlEO0FBQWpELGlEQUFpRDtBQUVqRCxPQUFPLEVBQUUsU0FBUyxFQUFjLFlBQVksRUFBcUIsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQy9GLE9BQU8sRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7QUFLOUMsTUFBTSxPQUFPLHlCQUF5QjtJQU9oQjtJQU5TLE1BQU0sR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0lBRWpELFlBQVksR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0lBQ2xDLFFBQVEsQ0FBQztJQUNULGlCQUFpQixHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7SUFFMUMsWUFBb0IsVUFBc0I7UUFBdEIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtJQUFHLENBQUM7SUFFOUMsV0FBVztRQUNULElBQUksSUFBSSxDQUFDLHlCQUF5QixFQUFFO1lBQ2xDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDdkQsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUNqQztJQUNILENBQUM7SUFFRCxRQUFRO1FBQ04sSUFBSSxJQUFJLENBQUMseUJBQXlCLEVBQUU7WUFDbEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLE1BQU0sQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFO2dCQUM3QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2xDLENBQUMsQ0FBQyxDQUFDO1lBRUgsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUVyRCxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FDbkIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQzFELElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDckIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztTQUNIO0lBQ0gsQ0FBQztJQUVELElBQVkseUJBQXlCO1FBQ25DLE9BQU8sT0FBTyxNQUFNLENBQUMsY0FBYyxLQUFLLFVBQVUsQ0FBQztJQUNyRCxDQUFDO21GQWxDVSx5QkFBeUI7NkRBQXpCLHlCQUF5Qjs7aUZBQXpCLHlCQUF5QjtjQUhyQyxTQUFTO2VBQUM7Z0JBQ1QsUUFBUSxFQUFFLHFCQUFxQjthQUNoQzsyQ0FFOEIsTUFBTTtrQkFBbEMsTUFBTTttQkFBQyxtQkFBbUIiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cInJlc2l6ZS1vYnNlcnZlci1icm93c2VyXCIgLz5cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbcC1yZXNpemUtb2JzZXJ2ZXJdJ1xufSlcbmV4cG9ydCBjbGFzcyBQb1Jlc2l6ZU9ic2VydmVyRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkluaXQge1xuICBAT3V0cHV0KCdwLXJlc2l6ZS1vYnNlcnZlcicpIHJlc2l6ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgcHJpdmF0ZSBvYnNlcnZlcjtcbiAgcHJpdmF0ZSBjaGFydFdpZHRoUmVzaXplJCA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7fVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmlzUmVzaXplT2JzZXJ2ZXJTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKHRoaXMuaXNSZXNpemVPYnNlcnZlclN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICB0aGlzLmNoYXJ0V2lkdGhSZXNpemUkLm5leHQoe30pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG5cbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChcbiAgICAgICAgdGhpcy5jaGFydFdpZHRoUmVzaXplJC5waXBlKGRlYm91bmNlVGltZSgyMCkpLnN1YnNjcmliZShfID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2l6ZS5lbWl0KCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGlzUmVzaXplT2JzZXJ2ZXJTdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbic7XG4gIH1cbn1cbiJdfQ==